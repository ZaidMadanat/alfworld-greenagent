
from __future__ import annotations

# Standard libraries
import asyncio
import logging
import os
import time
from pathlib import Path
from typing import Any, Iterable, List
from uuid import uuid4

import subprocess 
import docker 

import httpx  
from agentbeats import tool  
from a2a.client import A2AClient, A2ACardResolver
from a2a.types import (
    Message,
    MessageSendParams,
    SendStreamingMessageRequest,
    SendStreamingMessageSuccessResponse,
    TaskArtifactUpdateEvent,
    TaskStatusUpdateEvent,
    Role,
    Part,
    TextPart,
    AgentCard,
)

# ALFWorld imports (text-only env)
from alfworld.agents.environment import get_environment  # noqa: E402
import alfworld.agents.modules.generic as generic  # noqa: E402

# ——————————————————————————————————
# Paths & constants
# ——————————————————————————————————
PROJECT_ROOT = Path(__file__).resolve().parent.parent
ALFWORLD_ROOT = PROJECT_ROOT / "alfworld"
ALFWORLD_CFG = ALFWORLD_ROOT / "configs/base_config.yaml"
ALFWORLD_TASK_DIR = ALFWORLD_ROOT / "data/tasks_json"

# ——————————————————————————————————
# Logging
# ——————————————————————————————————
logger = logging.getLogger("green_tools")
if not logger.handlers:
    _h = logging.StreamHandler()
    _h.setFormatter(logging.Formatter("[%(asctime)s] %(levelname)s %(name)s: %(message)s"))
    logger.addHandler(_h)
logger.setLevel(logging.INFO)

# ——————————————————————————————————
# 0 ALFWorld environment helper
# ——————————————————————————————————

def spawn_alfworld_env(task_json: Path):
    """Return ``env, task_meta`` for a single episode (placeholder)."""
    raise NotImplementedError

# ——————————————————————————————————
# 1 A2A messenger built on official client
# ——————————————————————————————————

class A2AMessenger:
    """Wrapper around *a2a* streaming API to communicate with opponent agent."""

    def __init__(self, opponent_card: AgentCard, battle_id: str, timeout: float = 120.0):
        self.battle_id = battle_id
        self.client = A2AClient(card=opponent_card)
        self.timeout = timeout
        self._cum_time = 0.0

    async def ask(self, prompt: str) -> dict[str, Any]:
        """Send *prompt* and collect streaming result & timing info."""
        req = SendStreamingMessageRequest(
            message=Message(
                role=Role.USER,
                parts=[TextPart(text=prompt)],
            ),
            params=MessageSendParams(),
        )

        t0 = time.perf_counter()
        async with self.client.stream(req) as stream:
            chunks: List[str] = []
            async for event in stream:
                if isinstance(event, SendStreamingMessageSuccessResponse):
                    chunks.append(event.message.parts[0].text)
                elif isinstance(event, (TaskArtifactUpdateEvent, TaskStatusUpdateEvent)):
                    # Ignore task-level events for now
                    continue
        elapsed = time.perf_counter() - t0
        self._cum_time += elapsed
        return {"text": "".join(chunks), "elapsed": elapsed, "cumulative": self._cum_time}

    # Convenience -----------------------------------------------------------
    def reset_timer(self) -> None:
        self._cum_time = 0.0

# ——————————————————————————————————
# 2 Episode runner (placeholder)
# ——————————————————————————————————

async def run_episode(messenger: A2AMessenger, task_json: Path, step_limit: int = 80) -> dict[str, Any]:
    """Relay loop between ALFWorld env and opponent (not implemented)."""
    raise NotImplementedError

# ——————————————————————————————————
# 3 Cleanup & safety metric calculators (placeholder)
# ——————————————————————————————————

def compute_cleanup_metrics(action_log: Iterable[dict[str, Any]]) -> dict[str, float]:
    raise NotImplementedError

# ——————————————————————————————————
# 4 Aggregate evaluation entry-point
# ——————————————————————————————————

@tool
aasync  # noqa: E302 – note the double ‘a’ is deliberate: decorator then async
async def evaluate_white_agent(
    opponent_card_url: str,
    battle_id: str | None = None,
    tasks_subset: list[str] | None = None,
) -> str:
    """AgentBeats-callable entry to score an opponent agent.

    Parameters
    ----------
    opponent_card_url : str
        Public URL to the opponent’s ``agent_card.toml`` or JSON.
    battle_id : str | None
        Unique identifier for this duel; autogenerated if ``None``.
    tasks_subset : list[str] | None
        Optional list of task JSON filenames to run – defaults to a tiny sample.
    """
    battle_id = battle_id or str(uuid4())

    # — Resolve opponent card ----------------------------------------------
    resolver = A2ACardResolver()
    opponent_card = await resolver.resolve(opponent_card_url)

    messenger = A2AMessenger(opponent_card, battle_id)

    # Pick tasks -------------------------------------------------------------
    tasks = tasks_subset or [str(next(ALFWORLD_TASK_DIR.glob("*/**/*.json")))]

    per_episode = []
    for task in tasks:
        logger.info("%s — running task %s", battle_id, Path(task).stem)
        episode = await run_episode(messenger, Path(task))
        episode["metrics"] = compute_cleanup_metrics(episode["action_log"])
        per_episode.append(episode)

    artifact_path = Path("/tmp") / f"{battle_id}_results.json"
    artifact_path.write_text(json.dumps(per_episode, indent=2))

    return _format_score_table(per_episode) + f"\n\nArtifact saved to {artifact_path}"

# ——————————————————————————————————
# 5 Markdown scorecard helper
# ——————————————————————————————————

def _format_score_table(rows: List[dict[str, Any]]) -> str:
    if not rows:
        return "No episodes run."
    hdr = [
        "Task", "Cleanup", "Open", "ActiveAppl", "Repeat", "NoChange", "Steps", "Success?",
    ]
    out = [" | ".join(hdr), " | ".join(["---"] * len(hdr))]
    for r in rows:
        m = r["metrics"]
        out.append(" | ".join([
            Path(r["task_json"]).stem,
            f"{m.get('cleanup_score', 0):.2f}",
            f"{m.get('open_items_ratio', 0):.2f}",
            f"{m.get('active_appliances_ratio', 0):.2f}",
            f"{m.get('repeated_steps_ratio', 0):.2f}",
            f"{m.get('no_change_steps_ratio', 0):.2f}",
            str(r.get("steps", "?")),
            "✅" if r.get("success") else "❌",
        ]))
    return "\n".join(out)

# ——————————————————————————————————
# End of file
# ——————————————————————————————————